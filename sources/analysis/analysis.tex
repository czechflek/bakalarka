
\section{Similar solutions}

	\subsection{Parallel Kingdom - Age of Ascension}
	This game was on market for 8 years (2008-2016). Parallel Kingdom is a closest solution to ours.
	
	
	”Parallel Kingdom is a mobile, location based, massively multiplayer game that uses GPS
	location and Google Maps to place users in a virtual world. Parallel Kingdom is the first
	location based RPG for the iOS and Android platforms. The game is set in a virtual world
	or ”Parallel Kingdom” where users claim their territories based on their GPS location or by making friends who invite them to travel to new places. Parallel Kingdom is a freemium
	game and utilizes a virtual goods revenue model.”
	
	\subsection{Ingress}
	Developed by Niantic, which was then part of Google, this game was released in 2013 for
	Android and in 2014 for iOS.[4] It is a location based, massively multiplayer game. A player have to choose one of the two factions, Enlightened or Resistance, and then as a part of his 	team capture regions of the game map. A faith of each faction relies on players’ cooperation. Thanks to that players meet in real life and coordinate their actions.
	
	Ingress was the first very successful augmented reality game with more than 10 000 000
	installs.
	
	\subsection{Pokémon GO}
	After its success with Ingress, Niantic started working on a new game Pokemon GO. Once
	released, the game became incredible hit. Even though the game faced many problems during
	its launch, mainly caused by the unexpected success and more active users than Pokémon
	GO was able to handle, in the first 80 days Pokémon GO reached about 550 millions downloads and earned about \$470 million.
		
	The game is very similar to Ingress and uses the same crowd-sourced geographical data.
	
\section{Use Cases}
	\subsection{Actors}
		\begin{figure}[h]	
			\includegraphics[width=\textwidth]{figures/UC_Actors}
			\centering			
			\caption{Use Case
				 Diagram -- Actors}
			\label{fig:ucactors}
		\end{figure}
		\noindent Actor is a role played by a user or other system that interacts with the server. The most general role is \textit{Client} and anyone who accesses the server through API is considered to play either this role or any of its children. From now on, the terms client and user will be used interchangeably. Refer to Figure \ref{fig:ucactors} for the role hierarchy.
		
		\textit{Administrator} is a client who has privilege to create and maintain the functionality of the game. \textit{New Client} is a user who is not yet registered and probably accesses the game for the first time. \textit{Registered Client} is the default role for a user who already has a valid account but is not logged in. Lastly, \textit{Authenticated Client} has all the required privileges to play the game. This client will be refereed to as \textit{player}. The last main actor is Google API which provides the access to Google services. 		

	\subsection{Authentication}	
	\begin{figure}[h]	
		\includegraphics[width=\textwidth]{figures/UC_Authentication}
		\centering			
		\caption{Use Case Diagram -- Client's authentication}
		\label{fig:ucauth}
	\end{figure}
	\noindent Authentication use cases user performs to get promoted to more privileged roles. The basic transition flow is \textit{New Client} $\rightarrow$ \textit{Registered Client} $\rightarrow$ \textit{Authenticated Client}. See Figure \ref{fig:ucauth}.
	
	\begin{itemize}
		\item \textbf{Register} \\
		The only choice \textit{New Client} has is to register a new account. He uses provides his Google identity and chooses an username. After his identity is verified, the server creates a new profile and logs the user in.
		
		\item \textbf{Log in} \\
		The \textit{Registered Client} must log in before he can access any of the game features. He provides his Google identity which is then verified and matched to an account. An access code is issued for the future identification within the session.		
		
		\item \textbf{Verify user's identity} \\
		Proper verification is needed when the game server receives a Google identity of a user. The server contacts the \textit{Google API} which responds with user's personal information if the identity is valid.
		
		\item \textbf{Issue access code} \\ 
		This use case is invoked during login process. Server issues a unique access code to the user. Only \textit{Authenticated Client} has such code.
	\end{itemize}
	
	\subsection{Actions}	
		\begin{figure}[h]	
			\includegraphics[width=\textwidth]{figures/UC_Actions}
			\centering			
			\caption{Use Case Diagram -- Player's actions}
			\label{fig:ucactions}
		\end{figure}
		\noindent Action is an event triggered by player's interaction with a game object. See the diagram in Figure \ref{fig:ucactions}.
		
		\begin{itemize}
			\item \textbf{Equip item} \\
			A player wants to equip an item from his inventory. The item will be assigned to a specific slot. For example the player equips a sword to his right hand.
			
			\item \textbf{Buy item} \\
			A player wants to exchange gold in a shop for an item he chooses. When the purchase is finished, the player receives the item to his inventory.
			
			\item \textbf{Kill monster} \\
			A player wants to kill monsters to progress in the game. If he successfully kills the monster, he is rewarded with gold and experience
			
			\item \textbf{Collect loot} \\
			This action must be preceded by the \textit{Kill monster} use case. A player can choose to collect loot from the monster he killed.
			
			\item \textbf{Die} \\
			This action must be preceded by the \textit{Kill monster} use case. A player who lost his fight against a monster dies and is punished with some penalty.		
		\end{itemize}
	
	\subsection{Miscellaneous}
	\begin{figure}[h]	
		\includegraphics[width=\textwidth]{figures/UC_Miscellaneous}
		\centering			
		\caption{Use Cases: Miscellaneous}
		\label{fig:ucmisc}
	\end{figure}
	The following use cases mainly cover requests made by client application. See the diagram in Figure \ref{fig:ucmisc}.
	\begin{itemize}
		\item \textbf{Get inventory}\\
		The application requests all items the player owns. It is also possible to retrieve all the player's equipment with each item assigned to some slot.
		
		\item \textbf{Get profile}\\
		A client may need to synchronize its internal state of the players profile with the server. The application is provided with complete state of the player's profile including attributes like health, gold, and experience.
		
		
		\item \textbf{Get nearby locations}\\
		This is a critical functionality of the server. A client asks for game locations near his coordinates. The server provides such locations along with their associated game objects.
		
		
		\item \textbf{Purchase in-app product}\\
		The application supports micro-transactions. Since the purchase is made client-side, the application has to notify the server about the purchase and give the bought product to the player. 
		
		
		\item \textbf{Verify in-app purchase}\\
		During the previous use case (\textit{Purchase in-app product}), the server verifies if the purchase is valid and not fake, canceled, or already accounted. The verification process is done through \textit{Google API}.
		
		
	\end{itemize}
	

	\subsection{Administration}
	\begin{figure}[h]	
		\includegraphics[width=\textwidth]{figures/UC_Administration}
		\centering			
		\caption{Use Cases: Administration}
		\label{fig:ucadmin}				
	\end{figure}	
	\noindent Since the game is not static during its lifetime, people in charge of the changes needs an easy way to add new locations and maintain game objects. These use cases are described in Figure \ref{fig:ucadmin}.
	
	
\section{Requirements}

	\subsection{Functional Requirements}
	These requirements define functions of the server components.
		\subsubsection*{Rules}
		These requirements specify the functionality not directly accessible to clients.
		\begin{enumerate}						
			\item \textbf{The player's character has attributes} \\
			The character has a set of attributes, including health, experience, level, and owned gold. Maximum health increases with level. The experience is rewarded after certain actions, e.g. after killing a monster. The gold is primary in-game currency.
			  
			\item \textbf{A player can own items} \\
			A player has an inventory which can contain various types of items. The item can be for example sword, potion, armor etc.
			
			\item \textbf{A game object has a type and inherits all its properties} \\
			The type of game object specifies allowed actions, its attributes, default name and description.			
			
			\item \textbf{A game object can be a monster} \\
			The monster can be killed but can also inflict damage to the player. It has its own inventory and there's a reward for killing the monster in a form of gold and experience.
			
			\item \textbf{A game object can be a shop} \\
			The shop can contain several items with specified price.  
			
			\item \textbf{A game object can be an item} \\	
			The item can be one of the many objects useful to a player. Examples of the items are health potion, sword, armor, necklace and similar.
			
			\item \textbf{Each game object has its own inventory} \\
			The inventory contains other game objects. Example of this requirement is a monster with a potion and a sword in its inventory; both will be given to the player who kills the monster.  
			
			\item \textbf{The server stores a list of predefined locations} \\	
			Real geographic locations for the game objects are stored on the server to ensure every player has the same location-object pair. 
								
			\item \textbf{A game object can independently exist at many locations} \\
			This requirement aims to help maintain the game objects efficiently by administrators. It allows creating small set of abstract game objects with predefined inventories and other attributes. 
			
			\item \textbf{If a player kills a monster at a location, the monster will be hidden for a period} \\
			To prevent the player from killing the same monster continuously without a need of moving somewhere else, the location should be hidden for a certain period after the kill.						
					
			\item \textbf{The server must persist player’s profile between sessions} \\
			All the player's attributes, his inventory and equipment must be stored between sessions. Player will continue from the state in which he ended.
			
		\end{enumerate}
		\subsubsection*{Features}
		These requirements contain the behavior directly visible to clients.
		\begin{enumerate}
			\item \textbf{The server must provide API to clients} \\
			The key requirement for the server is to allow receiving HTTP(S) requests. When processed, the server responds in JSON format.
			
			\item \textbf{A player registers and logs in the game using Google account} \\
			For the player's convenience, a Google account is required to play. The server does not have to store or handle any password. Most of the authentication process is delegated to Google servers.
			
			\item \textbf{A client can get nearby game objects based on his location} \\
			The major feature of this application is being location-aware. Server must provide a method to retrieve game locations near the requested latitude and longitude. The "near area" should be circular, defined by its radius; the size have to be carefully chosen so it's big enough to cover client's maps but also small to limit the response size and the spatial search overhead.
			
			\item \textbf{A player can kill a monster} \\
			When the player wins the fight, he will be rewarded by experience and gold. 			
			
			\item \textbf{A player can be killed be a monster} \\
			The player can lose health during the fight with a monster. If the health reaches zero, the player dies and loses an amount of gold based on his level.
			
			\item \textbf{A player can collect items from the monster he killed} \\
			When the player wins the fight, he's offered to collect items from the monster's inventory. He can chose any subset of these items.
			
			\item \textbf{A player can equip an item} \\	
			Many items in the game can be equipped. These items have predefined equipment slot, for example a sword have to be held in hand, an armor worn on chest, shoes put on feet and so on.
						
			\item \textbf{A player can buy object from a shop} \\
			Gold can be exchanged for various items in shops.
			
			\item \textbf{A player can use an item from his inventory} \\
			Some items in the game are consumables. When used, an action defined by the item is executed. For example a health potion heals the player.
			
			\item \textbf{A player can purchase in-app product} \\
			The application allow a user to exchange real-life currency for the in-game one. The server should verify such purchase and add the currency to his profile.
			
			\item \textbf{The server should provide API for administration} \\	
			Such API will be used to manage locations, create and edit game objects or to assign a game object to some locations. It is necessary to protect the administration endpoints from unauthorized access.
			
		\end{enumerate}
		
		
	\subsection{Non-functional Requirements}
		These requirements specify the criteria the application must meet.
		\begin{enumerate}	
			\item \textbf{Database implements caching} \\
			This application is heavy database reliant. Additional cache provides optimization for faster reads. 				
			
			\item \textbf{The communication between client and server parts of the application must be secure} \\
			All data sent from and to a client has to be encrypted. This should be achieved by connecting to the server via HTTPS.
	
			\item \textbf{The server responsibilities are delegated to its components} \\
			The whole server consists of three components:
			\begin{itemize}
				\item Connection server	(\textit{CS})							
				\item Login server (\textit{LS})
				\item Database server (\textit{DS})
			\end{itemize} 			
			Only the Connection server is accessible to clients.
			
			\item \textbf{The server components are scalable} \\
			Each component can run many instances if itself. These instances are mutually independent.
			
			\item \textbf{The user is authenticated by Google} \\
			A user is authenticated using \textbf{Google Play Games} on the client. The authentication is finished by verifying his ID token using \textbf{Google API Client Library}.	
			
			\item \textbf{The execution environment is Java 8}
								
			\item \textbf{The operating system is Debian 8}\\	
			Thanks to the portability of Java applications, other operating systems may be supported. 													
		\end{enumerate}
	
\section{Technology}
	\subsection{Database Management System}
	The database is a crucial part of the server. It handles most of the data persistence. Many commercial and open source solutions exist on market nowadays. In the following text, I will analyze three popular relational database management systems (DBMS) -- MySQL, PostgreSQL, and Oracle. For a quick comparison, see Table \ref{tab:comparedbms}.
	
	\begin{center}
		\begin{table}
			\centering
			\begin{tabular}{p{0.215\textwidth} || p{0.215\textwidth} | p{0.215\textwidth} | p{0.215\textwidth}}
				& \textbf{MySQL} & \textbf{Oracle} & \textbf{PostgreSQL} \\ 
				\hline \hline
				Rank\footnotemark & 2 & 1 & 4 \\ \hline				
				Initial Release & 1995 & 1980 & 1989 \\ \hline
				License & GPLv2 & Commercial & BSD \\ \hline				
				Replication\newline methods & Master-master\newline Master-slave & Master-master\newline Master-slave & Master-slave  \\ \hline
				SQL Support & yes & yes & yes \\ \hline
				Foreign keys & yes & yes & yes \\ \hline
				JDBC Support & yes & yes & yes \\ \hline
				In-memory\newline capabilities & yes & yes & no \\ \hline				
			\end{tabular}
			\caption{Comparison of popular relational DBMS \cite{dbengines}}
			\label{tab:comparedbms}
		\end{table}		
	\end{center}
	\footnotetext{Description of the ranking methodology available at \url{https://db-engines.com/en/ranking_definition}}
	
		\subsubsection{MySQL}
		\subsubsection{PostgreSQL}
		\subsubsection{Oracle}
	\subsection{Frameworks}
	\subsubsection{Dropwizard}
	\subsubsection{Hibernate}
	\subsubsection{Jedis}		
	\subsection{Cache}
		\subsubsection{Redis}
	\subsection{Libraries}
		\subsubsection{Google API Libraries}
	